% !TEX root = ./../paper.tex

\section{Results}
\label{sec:results}

\subsection{Language}
\label{sec:results:language}

\sculpt as a programming language is a functioning language capable of writing any program.

As a first example and introduction to the language itself, we have implemented a simple program that calculates the Fibonacci sequence in \sculpt.

The language uses FILO (First In Last Out) stacks as its only data structure to store and manipulate data. Each stack is represented by a different shape other than the reserved shapes used by the instructions, and they are initialized on first call.
Stacks can hold an arbitrarily large amount of rational numbers.
Stacks allow the pop, push, move and duplicate operations.
Numbers are defined by their literal counterparts, and the language supports basic arithmetic.
Arithmetic operations are the only operations available in \sculpt.
Availabre operations are addition, subtraction, multiplication, comparison, modulo and division.
These are performed in two ways:

\begin{itemize}
    \item \textbf{As unary operator}: The first two elements of the stack given by parameter are popped and operated and pushing the result back into the stack.
    \item \textbf{As binary operator}: The first element of the stack given by parameter is popped and the second parameter, a number, are operated with the result of the first operation. The result is pushed back into the stack.
\end{itemize}

\sculpt allows for flow control through the use of loops, conditional blocks and jump blocks.
Loops are physically represented by a literal loop of connected blocks or a single block jump.
The jump block is a special block that allows for the execution to continue at any point by moving the execution pointer from the current block to another with the offset given by parameter.
Conditional statements are represented by a question block using a stack value as a parameter. Positive values are considered true and evaluate the following block, and negative values are considered false and do not evaluate the affected block, but rather skips the next instruction.


\sculpt is based on the physical blocks. Blocks as three-dimensional objects are unwieldy to be described in text.
Therefore, we have made several valid notations for \sculpt programs.
Every block is represented as a square with the shape of each block inside the square. 
The connections between blocks are represented by arrows between the squares.

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{figures/ArtlangFibpng}
    \caption{\sculpt Fibonacci program}
    \label{fig:artlangfib}
    \vspace{5pt}
\end{figure}

The program in Figure \ref{fig:artlangfib} fills the cirle stack with the numbers of the Fibonacci sequence.

The second notation is a more traditional notation, which is used by the \sculpter interpreter, which will be explained afterwards.
The program is written in a more traditional way, every block has a reserved name, connections are omitted. It reads as a list of instructions, somewhat similar to an assembly language.
Limitations of this implementation are that the program is not visually represented, connections between blocks are not shown and physical loops cannot be represented, forcing the user to only use jump operations for execution control.
Our Fibonacci implementation can be rewritten in \sculpter as follows.

\begin{algorithm}
    \caption{Fibonacci sequence in \sculpt}
    \label{alg:fib}
    \begin{algorithmic}
    \State $push~0$ \textbf{star}
    \State $push~0$ \textbf{circle}
    \State $push~1$ \textbf{circle}
    \State $push~1$ \textbf{triangle}
    \While{True}
        \State $dup$ \textbf{triangle}
        \State $dup$ \textbf{star}
        \State $mov$ \textbf{star} \textbf{trapezoid}
        \State $mov$ \textbf{triangle} \textbf{trapezoid}
        \State $add$ \textbf{trapezoid}
        \State $pop$ \textbf{star}
        \State $mov$ \textbf{triangle} \textbf{star}
        \State $dup$ \textbf{trapezoid}
        \State $mov$ \textbf{trapezoid} \textbf{circle}
        \State $mov$ \textbf{trapezoid} \textbf{triangle}
    \EndWhile
    \end{algorithmic}
    \end{algorithm}
\endinput

Writing a Fibonacci program is a simple task in \sculpt, yet it is not a complete proof of the language's capabilities.
The language is Turing complete, and it is capable of writing any program that can be written in any other programming language.
To validate this, we will simulate Turing machine in \sculpt.
The Turing machine is a theoretical model of computation that can simulate any algorithm.
For this instance, an implementation of a 3-State Busy Beaver Turing machine will be used.
The Busy Beaver is a theoretical Turing machine that is designed to run for the longest possible time before halting.
%Its \sculpt implementation is shown in Figure \ref{fig:busybeaver}.

% \begin{figure}
%     \centering
%     \includegraphics[width=0.5\textwidth]{figures/ArtlangBusyBeaver.png}
%     \caption{3-State Busy Beaver Turing machine in \sculpt}
%     \label{fig:busybeaver}
%     \vspace{5pt}
% \end{figure}

Its \sculpter implementation is as follows:

\begin{algorithm}
    \caption{3-State Busy Beaver Turing machine in \sculpt}
    \label{alg:busybeaver}
    \begin{algorithmic}
    \State $push~0$ \textbf{left}
    \State $push~0$ \textbf{left}
    \State $push~0$ \textbf{left}
    \State $push~0$ \textbf{left}
    \State $push~0$ \textbf{left}
    \State $push~0$ \textbf{left}
    \State $push~0$ \textbf{left}
    \State
    \State $push~0$ \textbf{right}
    \State $push~0$ \textbf{right}
    \State $push~0$ \textbf{right}
    \State $push~0$ \textbf{right}
    \State $push~0$ \textbf{right}
    \State $push~0$ \textbf{right}
    \State $push~0$ \textbf{right}
    \State
    \State $push~0$ \textbf{head}
    \State
    \State \textbf{// STATE A}
    \State $push~1$ \textbf{temp}
    \State $mov$ \textbf{temp} \textbf{head}
    \State $cmp$ \textbf{temp}
    \State $?$ \textbf{temp}
    \State $jmp~13$ \textbf{// A\_1}
    \State $push~1$ \textbf{head}
    \State $mov$ \textbf{right} \textbf{head}
    \State $mov$ \textbf{head} \textbf{left}
    \State
    \State \textbf{// STATE B}
    \State $push~1$ \textbf{temp}
    \State $mov$ \textbf{temp} \textbf{head}
    \State $cmp$ \textbf{temp}
    \State $?$ \textbf{temp}
    \State $jmp~9$
    \State $push~1$ \textbf{head}
    \State $mov$ \textbf{left} \textbf{head}
    \State $mov$ \textbf{head} \textbf{right}
    \State $jmp~-16$
    \State
    \State \textbf{// A\_1}
    \State $push~1$ \textbf{head}
    \State $mov$ \textbf{left} \textbf{head}
    \State $mov$ \textbf{head} \textbf{right}
    \State $jmp~5$
    \State
    \State \textbf{// B\_1}
    \State $push~1$ \textbf{head}
    \State $mov$ \textbf{right} \textbf{head}
    \State $mov$ \textbf{head} \textbf{left}
    \State $jmp~-16$
    \State
    \State \textbf{// STATE\_C}
    \State $push~1$ \textbf{temp}
    \State $mov$ \textbf{temp} \textbf{head}
    \State $cmp$ \textbf{temp}
    \State $?$ \textbf{temp}
    \State $jmp~5$
    \State $push~1$ \textbf{head}
    \State $mov$ \textbf{left} \textbf{head}
    \State $mov$ \textbf{head} \textbf{right}
    \State $jmp~-25$
    \State
    \State \textbf{// HALT}
    \State $push~1$ \textbf{head}
    \end{algorithmic}
\end{algorithm}

This simulation of the Busy Beaver Turing machine is a simple program that runs for some time before halting.
Since this simulation is of a Turing machine, it is capable of simulating any algorithm, thus proving that \sculpt is Turing complete.

\subsection{Validation}
\label{sec:results:validation}
\sculpt is a programming language that is designed to be used by artists and programmers alike.
The language is designed to be easy to use and understand, yet powerful enough to create complex programs.
To validate \sculpt, we have conducted a series of sessions with different users to test the language and its ecosystem.

\subsubsection{Regarding Aesthetics}
\label{sec:results:validation:aesthetics}
Special sessions were held with a group of artists to test their overall experience with \sculpt from their experience as artists.
Results were surprisingly positive, with most users reporting that they enjoyed the experience of using \sculpt.
Participants expressed their appreciation for the physicality of the blocks and the ability to manipulate them in a tangible way.
The physicality of the block was quintessential to their experience.
Participants also reported that the blocks were easy to understand and use, and that they enjoyed the process of building their sculptures.
When presented with the programming tasks, participants were able to understand the assignments, understand the block and their functionalities, but they were not able to complete any task.
Nevertheless, they expressed overall satisfaction while trying and failing to complete the tasks.
Participants reported that the experience of using \sculpt was enjoyable and that they would like to use it again in the future.
This last point lead to additional sessions with the same group of artists, as they were engaged with \sculpt and wanted to explore it further.
While trying and failing to complete the tasks, they used the blocks to create sculptures that were not intended to be functional, but rather artistic.
Participants reported that they enjoyed the process of creating sculptures and that they found it to be a rewarding experience.
Surprisingly, participants used the blocks in ways that were not intended from the start. Creating visually interesting constructs with this newfound freedom.


\subsubsection{Regarding Computation}